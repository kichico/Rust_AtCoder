{
	// Place your snippets for rust here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"modpow": {
		"prefix": "modpow",
		"body": [
			"#[allow(non_snake_case)]",
			"fn modpow(mut x: i128, mut n: i128, MOD: i128) -> i128 {",
			"    let mut ans = 1;",
			"    while n > 0 {",
			"        if n & 1 == 1 {",
			"            ans = (ans * x) % MOD;",
			"        }",
			"        x = (x * x) % MOD;",
			"        n >>= 1;",
			"    }",
			"    return ans;",
			"}",
			""
		],
		"description": ""
	},
	"to_Binary": {
		"prefix": "to_Binary",
		"body": [
			"#[allow(non_snake_case)]",
			"fn to_Binary(mut x: i128) -> Vec<char> {",
			"    let mut v: Vec<char> = Vec::new();",
			"    if x == 0 {",
			"        v.push('0');",
			"    }",
			"    while x > 0 {",
			"        let c = std::char::from_digit((x % 2) as u32, 10).unwrap();",
			"        v.push(c);",
			"        x /= 2;",
			"    }",
			"    v.reverse();",
			"    return v;",
			"}"
		],
		"description": ""
	},
	"BinarySearch": {
		"prefix": "BinarySearch",
		"body": [
			"let (mut left,mut right):(usize,usize)=(0,n);",
			"while right-left > 1{",
			"  let mid: usize = left + (right - left)/2;",
			"  if a[mid] > x {",
			"      right = mid;",
			"  }",
			"  else {",
			"      left = mid;",
			"  }",
			"}"
		],
		"description": "BinarySearch"
	},
	"grid": {
		"prefix": "grid",
		"body": [
			"#[allow(non_snake_case)]",
			"fn grid<T: Clone + Copy>(h: usize, w: usize, ini: T) -> Vec<Vec<T>> {",
			"    let ret: Vec<Vec<T>> = vec![vec![ini; w]; h];",
			"    return ret;",
			"}"
		],
		"description": "grid"
	},
	"enumeratePrime": {
		"prefix": "enumeratePrime",
		"body": [
			"fn isPrime(x: i64) -> bool {",
			"    for i in 2..x.sqrt() as i64 + 1 {",
			"        if x % i == 0 {",
			"            return false;",
			"        }",
			"    }",
			"    return true;",
			"}",
			"",
			"fn enumeratePrime(x: i64) -> Vec<i64> {",
			"    let mut prime: Vec<i64> = Vec::new();",
			"    let mut notp = vec![false; 1e6 as usize + 1];",
			"    for i in 2..min(x as usize + 1, 1e6 as usize) {",
			"        if notp[i] {",
			"            continue;",
			"        }",
			"        if isPrime(i as i64) {",
			"            prime.push(i as i64);",
			"        }",
			"        let mut coe = 1;",
			"        while coe * i <= x as usize {",
			"            notp[coe * i] = true;",
			"            coe += 1;",
			"        }",
			"    }",
			"    return prime;",
			"}",
		],
		"description": ""
	},
	"enumerateDivisor": {
		"prefix": "enumerateDivisor",
		"body": [
			"fn enumerateDivisor(x: i64) -> HashSet<i64> {",
			"    let mut Divisor: HashSet<i64> = HashSet::new();",
			"    let limit = x.sqrt() + 2;",
			"    for num in 1..limit {",
			"        if x % num == 0 {",
			"            Divisor.insert(num);",
			"            Divisor.insert(x / num);",
			"        }",
			"    }",
			"    return Divisor;",
			"}",
			""
		],
		"description": "enumerateDivisor"
	},
	"Disjoint Set and Union data structure": {
		"prefix": "UnionFind",
		"body": [
			"#[derive(Debug, Clone)]",
			"pub struct UnionFind {",
			"    parent: Vec<i64>,",
			"}",
			"",
			"impl UnionFind {",
			"    pub fn new(n: usize) -> Self {",
			"        let parent = vec![-1i64; n];",
			"        return UnionFind { parent };",
			"    }",
			"    pub fn find_root(&mut self, x: usize) -> usize {",
			"        if self.parent[x] < 0 {",
			"            return x;",
			"        }",
			"        self.parent[x] = self.find_root(self.parent[x] as usize) as i64;",
			"        return self.parent[x] as usize;",
			"    }",
			"    pub fn unite(&mut self, x: usize, y: usize) {",
			"        let mut xpar = self.find_root(x);",
			"        let mut ypar = self.find_root(y);",
			"        if xpar == ypar {",
			"            return;",
			"        }",
			"        if self.parent[xpar] > self.parent[ypar] {",
			"            std::mem::swap(&mut xpar, &mut ypar);",
			"        }",
			"        let x = xpar;",
			"        let y = ypar;",
			"        self.parent[x] += self.parent[y];",
			"        self.parent[y] = x as i64;",
			"    }",
			"    pub fn size(&mut self, x: usize) -> i64 {",
			"        let x = self.find_root(x);",
			"        return -self.parent[x];",
			"    }",
			"    pub fn equiv(&mut self, x: usize, y: usize) -> bool {",
			"        let x = self.find_root(x);",
			"        let y = self.find_root(y);",
			"        return x == y;",
			"    }",
			"}"
		],
		"description": "Disjoint Set and Union data structure"
	},
	"provide MultiSet Data Stracture": {
		"prefix": "MultiSet",
		"body": [
			"#[derive(Debug, Clone)]",
			"pub struct MultiSet<T>",
			"where",
			"    T: Copy + Clone + Hash + Eq + Ord,",
			"{",
			"    check: BTreeSet<T>,",
			"    counter: HashMap<T, i64>,",
			"    cnt: i64,",
			"}",
			"impl<T> MultiSet<T>",
			"where",
			"    T: Copy + Clone + Hash + Eq + Ord,",
			"{",
			"    pub fn new() -> Self {",
			"        let check: BTreeSet<T> = BTreeSet::new();",
			"        let counter: HashMap<T, i64> = HashMap::new();",
			"        let cnt = 0;",
			"        return MultiSet {",
			"            check,",
			"            counter,",
			"            cnt,",
			"        };",
			"    }",
			"    pub fn max(&self) -> Option<&T> {",
			"        if let Some(max_value) = self.check.iter().next_back() {",
			"            return Some(max_value);",
			"        } else {",
			"            return None;",
			"        }",
			"    }",
			"    pub fn min(&self) -> Option<&T> {",
			"        if let Some(min_value) = self.check.iter().next() {",
			"            return Some(min_value);",
			"        } else {",
			"            return None;",
			"        }",
			"    }",
			"    pub fn insert(&mut self, x: T) -> Option<T>",
			"    where",
			"        T: Copy + Clone + Ord + Hash,",
			"    {",
			"        if let Some(_i) = self.check.get(&x) {",
			"            *self.counter.entry(x).or_insert(0) += 1;",
			"        } else {",
			"            self.check.insert(x);",
			"            *self.counter.entry(x).or_insert(0) += 1;",
			"        }",
			"        return Some(x);",
			"    }",
			"    pub fn contains(&self, x: T) -> bool",
			"    where",
			"        T: Copy + Clone + Ord + Hash,",
			"    {",
			"        if let Some(_x) = self.check.get(&x) {",
			"            return true;",
			"        } else {",
			"            return false;",
			"        }",
			"    }",
			"    pub fn remove(&mut self, x: T) -> Option<T>",
			"    where",
			"        T: Copy + Clone + Ord + Hash,",
			"    {",
			"        if let Some(_x) = self.check.get(&x) {",
			"            if *self.counter.get(&x).unwrap() == 1 {",
			"                self.counter.remove(&x);",
			"                self.check.remove(&x);",
			"                return Some(x);",
			"            } else {",
			"                let v = self.counter.get_mut(&x);",
			"                match v {",
			"                    Some(v) => *v -= 1,",
			"                    None => (),",
			"                }",
			"                return Some(x);",
			"            }",
			"        } else {",
			"            None",
			"        }",
			"    }",
			"    pub fn remove_all(&mut self, x: T) -> Option<T>",
			"    where",
			"        T: Copy + Clone + Ord + Hash,",
			"    {",
			"        if let Some(_x) = self.check.get(&x) {",
			"            self.counter.remove(&x);",
			"            self.check.remove(&x);",
			"            return Some(x);",
			"        } else {",
			"            None",
			"        }",
			"    }",
			"    pub fn clear(&mut self) -> bool",
			"    where",
			"        T: Copy + Clone + Ord + Hash,",
			"    {",
			"        if !self.check.is_empty() {",
			"            self.check.clear();",
			"            self.counter.clear();",
			"            return true;",
			"        } else {",
			"            return false;",
			"        }",
			"    }",
			"    pub fn is_empty(&self) -> bool {",
			"        if self.check.is_empty() {",
			"            true",
			"        } else {",
			"            false",
			"        }",
			"    }",
			"}"
		],
		"description": "provide MultiSet Data Stracture"
	},
	"provide Usize rangeset": {
		"prefix": "rangeset",
		"body": [
			"pub struct RangeSet {",
			"    st: BTreeSet<(usize, usize)>,",
			"    range_length: usize,",
			"}",
			"impl RangeSet {",
			"    pub fn new() -> Self {",
			"        let st: BTreeSet<(usize, usize)> = BTreeSet::new();",
			"        let range_length = 0;",
			"        return RangeSet { st, range_length };",
			"    }",
			"    pub fn len(&self) -> usize {",
			"        return self.st.len();",
			"    }",
			"    pub fn range_len(&self) -> usize {",
			"        return self.range_length;",
			"    }",
			"    pub fn find(&self, target: &usize) -> Option<(usize, usize)> {",
			"        let mut lower_bound = self",
			"            .st",
			"            .range((Unbounded, Excluded((target + 1, target + 1))));",
			"        if let Some(value) = lower_bound.next_back() {",
			"            if value.1 < *target {",
			"                return None;",
			"            } else {",
			"                return Some(*value);",
			"            }",
			"        } else {",
			"            return None;",
			"        }",
			"    }",
			"    pub fn contains(&self, target: &usize) -> bool {",
			"        if let Some(_value) = self.find(target) {",
			"            return true;",
			"        } else {",
			"            return false;",
			"        }",
			"    }",
			"    pub fn insert(&mut self, mut left: usize, mut right: usize) -> bool {",
			"        if left >= right {",
			"            return false;",
			"        }",
			"        let mut existing = self.st.range((Unbounded, Included((right, right))));",
			"        let mut will_remove: Vec<(usize, usize)> = Vec::new();",
			"        let mut range_len_diff = 0i64;",
			"        while let Some((el, er)) = existing.next_back() {",
			"            if *el <= right && left <= *er {",
			"                will_remove.push((*el, *er));",
			"                left = left.min(*el);",
			"                right = right.max(*er);",
			"            } else {",
			"                break;",
			"            }",
			"        }",
			"        let mut existing = self.st.range((Included((left, left)), Unbounded));",
			"        while let Some((el, er)) = existing.next() {",
			"            if *el <= right && left <= *er {",
			"                will_remove.push((*el, *er));",
			"                left = left.min(*el);",
			"                right = right.max(*er);",
			"            } else {",
			"                break;",
			"            }",
			"        }",
			"        if !will_remove.is_empty() {",
			"            for p in will_remove {",
			"                self.st.remove(&p);",
			"                range_len_diff -= (p.1 - p.0) as i64;",
			"            }",
			"        }",
			"        self.st.insert((left, right));",
			"        range_len_diff += (right - left) as i64;",
			"        self.range_length = (self.range_length as i64 + range_len_diff) as usize;",
			"        return true;",
			"    }",
			"    pub fn remove(&mut self, left: usize, right: usize) {",
			"        assert!(left <= right);",
			"        let mut existing = self.st.range((Unbounded, Included((right, right))));",
			"        let mut will_remove: Vec<(usize, usize)> = Vec::new();",
			"        let mut range_len_diff = 0i64;",
			"        while let Some((el, er)) = existing.next_back() {",
			"            if *el <= right && left <= *er {",
			"                will_remove.push((*el, *er));",
			"            } else {",
			"                break;",
			"            }",
			"        }",
			"        if !will_remove.is_empty() {",
			"            for p in will_remove {",
			"                let (el, er) = p;",
			"                self.st.remove(&p);",
			"                range_len_diff -= (p.1 - p.0) as i64;",
			"                if el <= left && right <= er {",
			"                    self.insert(el, left);",
			"                    self.insert(right, er);",
			"                } else if left <= er && right <= er {",
			"                    self.insert(el, left);",
			"                } else if left <= el && right <= er {",
			"                    self.insert(right, er);",
			"                }",
			"            }",
			"        }",
			"        self.range_length = (self.range_length as i64 + range_len_diff) as usize;",
			"    }",
			"    pub fn mex(&self) -> usize {",
		  	"	   if let Some((_l, r)) = self.find(&0) {",
		  	"		 return r;",
		  	"	} else {",
		  	"		return 0;",
		  	"	}",
			"}",
			"}"
		],
		"description": "provide Usize rangeset"
	},
	"prime factorize": {
		"prefix": "prime factorize",
		"body": [
			"#[allow(non_snake_case)]",
			"fn prime_factorize(mut x: i64) -> Vec<(i64, i64)> {",
			"    let mut factor: Vec<(i64, i64)> = Vec::new();",
			"    let sq = x.sqrt() + 1;",
			"    let mut isSeeked = vec![true; sq as usize + 1];",
			"    for i in 2..=sq {",
			"        if !isSeeked[i as usize] {",
			"            continue;",
			"        }",
			"        let mut exp_num = 0;",
			"        while x % i == 0 {",
			"            exp_num += 1;",
			"            x /= i;",
			"        }",
			"        for n in (i * 2..=sq).step_by(i as usize) {",
			"            isSeeked[n as usize] = false;",
			"        }",
			"        if exp_num != 0 {",
			"            factor.push((i, exp_num));",
			"        }",
			"    }",
			"    if x > 1 {",
			"        factor.push((x, 1));",
			"    }",
			"    return factor;",
			"}"
		],
		"description": "prime factorize"
	},
	"Calculate shortest path by using Dijkstra's Method": {
		"prefix": "dijkstra",
		"body": [
			"#[allow(non_snake_case)]",
			"#[derive(Clone)]",
			"struct Edge {",
			"    to: usize,",
			"    cost: i64,",
			"}",
			"",
			"#[derive(Clone)]",
			"struct Dijkstra {",
			"    graph: Vec<Vec<Edge>>,",
			"    from_record: Vec<usize>,",
			"    nodes: usize,",
			"}",
			"",
			"impl Dijkstra {",
			"    pub fn new(n: usize) -> Self {",
			"        let graph: Vec<Vec<Edge>> = vec![Vec::new(); n];",
			"        let from_record: Vec<usize> = vec![n + 1; n];",
			"        let nodes = n;",
			"        return Dijkstra {",
			"            graph,",
			"            from_record,",
			"            nodes,",
			"        };",
			"    }",
			"    pub fn add_edge(&mut self, from: usize, to: usize, cost: i64) {",
			"        assert!(from != to);",
			"        self.graph[from].push(Edge { to, cost });",
			"    }",
			"    pub fn calc_shortest_distance(&mut self, start: usize) -> Vec<i64> {",
			"        let mut dist = vec![1e18 as i64 + 1; self.nodes];",
			"        //min-heap",
			"        let mut heap: BinaryHeap<(std::cmp::Reverse<i64>, usize)> = BinaryHeap::new();",
			"        heap.push((Reverse(0), start));",
			"        dist[start] = 0;",
			"        while let Some((Reverse(min_dist), v)) = heap.pop() {",
			"            if dist[v] < min_dist {",
			"                continue;",
			"            }",
			"            for e in &self.graph[v] {",
			"                if dist[e.to] > dist[v] + e.cost {",
			"                    dist[e.to] = dist[v] + e.cost;",
			"                    heap.push((Reverse(dist[e.to]), e.to));",
			"                    self.from_record[e.to] = v;",
			"                }",
			"            }",
			"        }",
			"        return dist;",
			"    }",
			"    pub fn get_shortest_path(&mut self, mut goal: usize) -> Vec<usize> {",
			"        let mut path: Vec<usize> = Vec::new();",
			"        while goal != self.nodes {",
			"            path.push(goal);",
			"            goal = self.from_record[goal];",
			"        }",
			"        return path;",
			"    }",
			"}"
		],
		"description": "Calculate shortest path by using Dijkstra's Method"
	},
	"topological sort": {
		"prefix": "topological sort",
		"body": [
			"#[derive(Debug, Clone)]",
			"pub struct TopologicalSort {",
			"    graph: Vec<Vec<usize>>,",
			"    deg: Vec<usize>,",
			"    res: Vec<usize>,",
			"}",
			"impl TopologicalSort {",
			"    pub fn new(v: usize) -> Self {",
			"        let graph: Vec<Vec<usize>> = vec![Vec::new(); v];",
			"        let deg = vec![0usize; v];",
			"        let res: Vec<usize> = Vec::new();",
			"        TopologicalSort {",
			"            graph: graph,",
			"            deg: deg,",
			"            res: res,",
			"        }",
			"    }",
			"    pub fn add_edge(&mut self, from: usize, to: usize) {",
			"        self.graph[from].push(to);",
			"        //入次数を増やす",
			"        self.deg[to] += 1;",
			"    }",
			"    pub fn solve(&mut self) -> bool {",
			"        let mut heap: BinaryHeap<std::cmp::Reverse<usize>> = BinaryHeap::new();",
			"        let v = self.graph.len();",
			"        for i in 0..v {",
			"            if self.deg[i] == 0 {",
			"                heap.push(Reverse(i));",
			"            }",
			"        }",
			"        while let Some(Reverse(u)) = heap.pop() {",
			"            self.res.push(u);",
			"            for neighbor in &self.graph[u] {",
			"                self.deg[*neighbor] -= 1;",
			"                if self.deg[*neighbor] == 0 {",
			"                    heap.push(Reverse(*neighbor));",
			"                }",
			"            }",
			"        }",
			"        for d in &self.deg {",
			"            if *d != 0 {",
			"                return false;",
			"            }",
			"        }",
			"        return true;",
			"    }",
			"    pub fn get_topological_order(self) -> Vec<usize> {",
			"        return self.res;",
			"    }",
			"}"
		],
		"description": "provide topologocal order nodes",
	},
	"Eratosthenes sieve provider": {
		"prefix": "eratosthenes",
		"body": [
			"#[derive(Debug, Clone)]",
			"pub struct Eratosthenes {",
			"    min_factor: Vec<usize>,",
			"}",
			"",
			"impl Eratosthenes {",
			"    pub fn new(n: i64) -> Self {",
			"        let n = n as usize;",
			"        let mut min_factor = vec![0usize; n as usize + 1];",
			"        min_factor[1] = 1;",
			"        for i in 2..=n {",
			"            if min_factor[i] != 0 {",
			"                continue;",
			"            }",
			"            min_factor[i] = i;",
			"            for factor in (i * 2..=n).step_by(i) {",
			"                if min_factor[factor] == 0 {",
			"                    min_factor[factor] = i;",
			"                }",
			"            }",
			"        }",
			"        return Eratosthenes { min_factor };",
			"    }",
			"    pub fn prime_factorize(&mut self, n: i64) -> Vec<(i64, i64)> {",
			"        let mut n = n as usize;",
			"        let mut ret: Vec<(i64, i64)> = Vec::new();",
			"        while n > 1 {",
			"            let p = self.min_factor[n] as usize;",
			"            let mut exp = 0;",
			"            while self.min_factor[n] == p {",
			"                n /= p;",
			"                exp += 1;",
			"            }",
			"            ret.push((p as i64, exp));",
			"        }",
			"        return ret;",
			"    }",
			"    pub fn enumerate_divisors(&mut self, n: i64) -> Vec<i64> {",
			"        let mut ret = vec![1i64];",
			"        let pf = self.prime_factorize(n);",
			"        for (prime, exp) in pf {",
			"            let mut divisor = 1;",
			"            for _i in 0..exp {",
			"                divisor *= prime;",
			"                ret.push(divisor);",
			"            }",
			"        }",
			"        ret.sort();",
			"        return ret;",
			"    }",
			"}"
		],
		"description": "Eratosthenes sieve provider"
	},
	"PotentializedUnionFind": {
		"prefix": "PotentializedUnionFind",
		"body": [
			"#[derive(Debug, Clone)]",
			"pub struct PotentializedUnionFind {",
			"    parent: Vec<i64>,",
			"    diff_potential: Vec<i64>,",
			"}",
			"",
			"impl PotentializedUnionFind {",
			"    pub fn new(n: usize) -> Self {",
			"        let parent = vec![-1i64; n];",
			"        let diff_potential = vec![0i64; n];",
			"        return PotentializedUnionFind {",
			"            parent,",
			"            diff_potential,",
			"        };",
			"    }",
			"    pub fn find_root(&mut self, x: usize) -> usize {",
			"        if self.parent[x] < 0 {",
			"            return x;",
			"        }",
			"        let root = self.find_root(self.parent[x] as usize) as i64;",
			"        self.diff_potential[x] += self.diff_potential[self.parent[x] as usize];",
			"        self.parent[x] = root;",
			"        return self.parent[x] as usize;",
			"    }",
			"    pub fn get_potential(&mut self, x: usize) -> i64 {",
			"        let _r = self.find_root(x);",
			"        return self.diff_potential[x];",
			"    }",
			"    pub fn get_diff(&mut self, x: usize, y: usize) -> i64 {",
			"        return self.get_potential(y) - self.get_potential(x);",
			"    }",
			"    pub fn unite(&mut self, x: usize, y: usize, mut potential: i64) {",
			"        potential += self.get_potential(x);",
			"        potential -= self.get_potential(y);",
			"        let mut xpar = self.find_root(x);",
			"        let mut ypar = self.find_root(y);",
			"        if xpar == ypar {",
			"            return;",
			"        }",
			"        if self.parent[xpar] > self.parent[ypar] {",
			"            std::mem::swap(&mut xpar, &mut ypar);",
			"            potential = -potential;",
			"        }",
			"        let x = xpar;",
			"        let y = ypar;",
			"        self.parent[x] += self.parent[y];",
			"        self.parent[y] = x as i64;",
			"        self.diff_potential[y] = potential;",
			"    }",
			"    pub fn size(&mut self, x: usize) -> i64 {",
			"        let x = self.find_root(x);",
			"        return -self.parent[x];",
			"    }",
			"    pub fn equiv(&mut self, x: usize, y: usize) -> bool {",
			"        let x = self.find_root(x);",
			"        let y = self.find_root(y);",
			"        return x == y;",
			"    }",
			"}"
		],
		"description": "PotentializedUnionFind"
	},
	"RollbackUnionFind": {
		"prefix": "RollbackUnionFind",
		"body": [
			"",
			"#[derive(Debug, Clone)]",
			"pub struct RollbackUnionFind {",
			"    parent: Vec<i64>,",
			"    history: Vec<(i64, i64)>,",
			"    inner_snap: usize,",
			"}",
			"",
			"impl RollbackUnionFind {",
			"    pub fn new(n: usize) -> Self {",
			"        let parent = vec![-1i64; n];",
			"        let history: Vec<(i64, i64)> = Vec::new();",
			"        let inner_snap = 0;",
			"        return RollbackUnionFind {",
			"            parent,",
			"            history,",
			"            inner_snap,",
			"        };",
			"    }",
			"    pub fn find_root(&mut self, x: usize) -> usize {",
			"        if self.parent[x] < 0 {",
			"            return x;",
			"        }",
			"        self.parent[x] = self.find_root(self.parent[x] as usize) as i64;",
			"        return self.parent[x] as usize;",
			"    }",
			"    pub fn unite(&mut self, x: usize, y: usize) {",
			"        let mut xpar = self.find_root(x);",
			"        let mut ypar = self.find_root(y);",
			"        if xpar == ypar {",
			"            return;",
			"        }",
			"        self.history.push((xpar as i64, self.parent[xpar]));",
			"        self.history.push((ypar as i64, self.parent[ypar]));",
			"        if self.parent[xpar] > self.parent[y] {",
			"            std::mem::swap(&mut xpar, &mut ypar);",
			"        }",
			"        let x = xpar;",
			"        let y = ypar;",
			"        self.parent[x] += self.parent[y];",
			"        self.parent[y] = x as i64;",
			"    }",
			"    pub fn size(&mut self, x: usize) -> i64 {",
			"        let x = self.find_root(x);",
			"        return -self.parent[x];",
			"    }",
			"    pub fn equiv(&mut self, x: usize, y: usize) -> bool {",
			"        let x = self.find_root(x);",
			"        let y = self.find_root(y);",
			"        return x == y;",
			"    }",
			"    pub fn undo(&mut self) {",
			"        if let Some((x, data)) = self.history.pop() {",
			"            self.parent[x as usize] = data;",
			"        }",
			"        if let Some((x, data)) = self.history.pop() {",
			"            self.parent[x as usize] = data;",
			"        }",
			"    }",
			"    pub fn snapshot(&mut self) {",
			"        self.inner_snap = self.history.len() >> 1;",
			"    }",
			"    pub fn recorded_state(&self) -> usize {",
			"        return self.history.len() >> 1;",
			"    }",
			"    pub fn roll_back(&mut self, state: i64) {",
			"        let mut target = if state == -1 {",
			"            self.inner_snap",
			"        } else {",
			"            state as usize",
			"        };",
			"        target <<= 1;",
			"        assert!(target <= self.history.len());",
			"        while target < self.history.len() {",
			"            self.undo();",
			"        }",
			"    }",
			"}"
		],
		"description": "RollbackUnionFind"
	},
	"Provide Reversal Binary Heap": {
		"prefix": "BinaryHeapReversal",
		"body": [
			"",
			"#[derive(Debug, Clone)]",
			"pub struct ReversalBinaryHeap<T>",
			"where",
			"    T: Copy + Clone + Hash + Eq + Ord,",
			"{",
			"    heap: BinaryHeap<Reverse<T>>,",
			"}",
			"",
			"impl<T> ReversalBinaryHeap<T>",
			"where",
			"    T: Copy + Clone + Hash + Eq + Ord,",
			"{",
			"    pub fn new() -> Self {",
			"        let heap: BinaryHeap<Reverse<T>> = BinaryHeap::new();",
			"        ReversalBinaryHeap { heap: heap }",
			"    }",
			"    pub fn push(&mut self, x: T) {",
			"        self.heap.push(Reverse(x));",
			"    }",
			"    pub fn pop(&mut self) -> Option<T> {",
			"        let val = self.heap.pop();",
			"        let x = match val {",
			"            Some(val) => Some(val.0),",
			"            None => None,",
			"        };",
			"        x",
			"    }",
			"    pub fn from(v: Vec<T>) -> Self {",
			"        let mut heap: BinaryHeap<Reverse<T>> = BinaryHeap::new();",
			"        for val in &v {",
			"            heap.push(Reverse(*val));",
			"        }",
			"        ReversalBinaryHeap { heap: heap }",
			"    }",
			"    pub fn clear(&mut self) {",
			"        self.heap.clear();",
			"    }",
			"    pub fn len(&mut self) -> usize {",
			"        self.heap.len()",
			"    }",
			"}"
		],
		"description": "Provide Reversal Binary Heap"
	},
	"rotate": {
		"prefix": "rotate",
		"body": [
			"fn rot(mat: Vec<Vec<char>>) -> Vec<Vec<char>> {",
			"    let mut ret = vec![vec!['.'; mat[0].len()]; mat.len()];",
			"    for i in 0..mat[0].len() {",
			"        for j in 0..mat.len() {",
			"            ret[i][j] = mat[mat.len() - 1 - j][i];",
			"        }",
			"    }",
			"    return ret;",
			"}"
		],
		"description": "rotate"
	},
	"provide longest common subsequence": {
		"prefix": "lcs",
		"body": [
			"",
			"fn longest_common_subsequence(s: Vec<char>, t: Vec<char>) -> String {",
			"    let mut dp = vec![vec![0usize; t.len() + 1]; s.len() + 1];",
			"    for i in 0..s.len() {",
			"        for j in 0..t.len() {",
			"            if s[i] == t[j] {",
			"                dp[i + 1][j + 1] = dp[i][j] + 1;",
			"            } else {",
			"                dp[i + 1][j + 1] = dp[i][j + 1].max(dp[i + 1][j]);",
			"            }",
			"        }",
			"    }",
			"    let mut r = s.len();",
			"    let mut c = t.len();",
			"    let mut ans: Vec<char> = Vec::new();",
			"    while r != 0 && c != 0 {",
			"        if dp[r][c] == dp[r][c - 1] {",
			"            c -= 1;",
			"            continue;",
			"        } else if dp[r][c] == dp[r - 1][c] {",
			"            r -= 1;",
			"            continue;",
			"        }",
			"        r -= 1;",
			"        c -= 1;",
			"        ans.push(s[r]);",
			"    }",
			"    ans.reverse();",
			"    return ans.iter().collect::<String>();",
			"}"
		],
		"description": "provide longest common subsequence"
	},
	"return Run Length compressioned vector": {
		"prefix": "run_length_compression",
		"body": [
			"fn run_length_compression<T>(v: Vec<T>) -> Vec<(T, usize)>",
			"where",
			"    T: Clone + Copy + PartialEq,",
			"{",
			"    let mut ret: Vec<(T, usize)> = Vec::new();",
			"    let mut last_element = v[0];",
			"    let mut len = 1;",
			"    for i in 1..v.len() {",
			"        if v[i] == last_element {",
			"            len += 1;",
			"        } else {",
			"            ret.push((last_element, len));",
			"            last_element = v[i];",
			"            len = 1;",
			"        }",
			"    }",
			"    ret.push((last_element, len));",
			"    return ret;",
			"}"
		],
		"description": "return Run Length compressioned vector"
	}
}