{
	// Place your snippets for rust here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"modpow": {
		"prefix": "modpow",
		"body": [
			"#[allow(non_snake_case)]",
			"fn modpow(mut x: i128, mut n: i128, MOD: i128) -> i128 {",
			"    let mut ans = 1;",
			"    while n > 0 {",
			"        if n & 1 == 1 {",
			"            ans = (ans * x) % MOD;",
			"        }",
			"        x = (x * x) % MOD;",
			"        n >>= 1;",
			"    }",
			"    return ans;",
			"}",
			""
		],
		"description": ""
	},
	"to_Binary": {
		"prefix": "to_Binary",
		"body": [
			"#[allow(non_snake_case)]",
			"fn to_Binary(mut x: i128) -> Vec<char> {",
			"    let mut v: Vec<char> = Vec::new();",
			"    if x == 0 {",
			"        v.push('0');",
			"    }",
			"    while x > 0 {",
			"        let c = std::char::from_digit((x % 2) as u32, 10).unwrap();",
			"        v.push(c);",
			"        x /= 2;",
			"    }",
			"    v.reverse();",
			"    return v;",
			"}"
		],
		"description": ""
	},
	"BinarySearch": {
		"prefix": "BinarySearch",
		"body": [
			"let (mut left,mut right):(usize,usize)=(0,n);",
			"while right-left > 1{",
			"  let mid: usize = left + (right - left)/2;",
			"  if a[mid] > x {",
			"      right = mid;",
			"  }",
			"  else {",
			"      left = mid;",
			"  }",
			"}"
		],
		"description": "BinarySearch"
	},
	"grid": {
		"prefix": "grid",
		"body": [
			"#[allow(non_snake_case)]",
			"fn grid<T: Clone + Copy>(h: usize, w: usize, ini: T) -> Vec<Vec<T>> {",
			"    let ret: Vec<Vec<T>> = vec![vec![ini; w]; h];",
			"    return ret;",
			"}"
		],
		"description": "grid"
	},
	"enumeratePrime": {
		"prefix": "enumeratePrime",
		"body": [
			"fn isPrime(x: i64) -> bool {",
			"    for i in 2..x.sqrt() as i64 + 1 {",
			"        if x % i == 0 {",
			"            return false;",
			"        }",
			"    }",
			"    return true;",
			"}",
			"",
			"fn enumeratePrime(x: i64) -> Vec<i64> {",
			"    let mut prime: Vec<i64> = Vec::new();",
			"    let mut notp = vec![false; 1e6 as usize + 1];",
			"    for i in 2..min(x as usize + 1, 1e6 as usize) {",
			"        if notp[i] {",
			"            continue;",
			"        }",
			"        if isPrime(i as i64) {",
			"            prime.push(i as i64);",
			"        }",
			"        let mut coe = 1;",
			"        while coe * i <= x as usize {",
			"            notp[coe * i] = true;",
			"            coe += 1;",
			"        }",
			"    }",
			"    return prime;",
			"}",
		],
		"description": ""
	},
	"enumerateDivisor": {
		"prefix": "enumerateDivisor",
		"body": [
			"fn enumerateDivisor(x: i64) -> HashSet<i64> {",
			"    let mut Divisor: HashSet<i64> = HashSet::new();",
			"    let limit = x.sqrt() + 2;",
			"    for num in 1..limit {",
			"        if x % num == 0 {",
			"            Divisor.insert(num);",
			"            Divisor.insert(x / num);",
			"        }",
			"    }",
			"    return Divisor;",
			"}",
			""
		],
		"description": "enumerateDivisor"
	},
	"Disjoint Set and Union data structure": {
		"prefix": "UnionFind",
		"body": [
			"#[derive(Debug, Clone)]",
			"pub struct UnionFind {",
			"    parent: Vec<i64>,",
			"}",
			"",
			"impl UnionFind {",
			"    pub fn new(n: usize) -> Self {",
			"        let parent = vec![-1i64; n];",
			"        return UnionFind { parent };",
			"    }",
			"    pub fn find_root(&mut self, x: usize) -> usize {",
			"        if self.parent[x] < 0 {",
			"            return x;",
			"        }",
			"        self.parent[x] = self.find_root(self.parent[x] as usize) as i64;",
			"        return self.parent[x] as usize;",
			"    }",
			"    pub fn unite(&mut self, x: usize, y: usize) {",
			"        let mut xpar = self.find_root(x);",
			"        let mut ypar = self.find_root(y);",
			"        if xpar == ypar {",
			"            return;",
			"        }",
			"        if self.parent[xpar] > self.parent[y] {",
			"            swap(&mut xpar, &mut ypar);",
			"        }",
			"        let x = xpar;",
			"        let y = ypar;",
			"        self.parent[x] += self.parent[y];",
			"        self.parent[y] = x as i64;",
			"    }",
			"    pub fn size(&mut self, x: usize) -> i64 {",
			"        let x = self.find_root(x);",
			"        return -self.parent[x];",
			"    }",
			"    pub fn equiv(&mut self, x: usize, y: usize) -> bool {",
			"        let x = self.find_root(x);",
			"        let y = self.find_root(y);",
			"        return x == y;",
			"    }",
			"}"
		],
		"description": "Disjoint Set and Union data structure"
	},
	"MultiSet": {
		"prefix": "MultiSet",
		"body": [
			"#[derive(Debug, Clone)]",
			"pub struct MultiSet<T>",
			"where",
			"    T: Copy + Clone + Hash + Eq + Ord,",
			"{",
			"    check: BTreeSet<T>,",
			"    counter: HashMap<T, i64>,",
			"}",
			"impl<T> MultiSet<T>",
			"where",
			"    T: Copy + Clone + Hash + Eq + Ord,",
			"{",
			"    pub fn new() -> Self {",
			"        let check: BTreeSet<T> = BTreeSet::new();",
			"        let counter: HashMap<T, i64> = HashMap::new();",
			"        return MultiSet { check, counter };",
			"    }",
			"    pub fn max(&self) -> Option<&T> {",
			"        if let Some(max_value) = self.check.iter().next_back() {",
			"            return Some(max_value);",
			"        } else {",
			"            return None;",
			"        }",
			"    }",
			"    pub fn min(&self) -> Option<&T> {",
			"        if let Some(min_value) = self.check.iter().next() {",
			"            return Some(min_value);",
			"        } else {",
			"            return None;",
			"        }",
			"    }",
			"    pub fn insert(&mut self, x: T) -> Option<T>",
			"    where",
			"        T: Copy + Clone + Ord + Hash,",
			"    {",
			"        if let Some(_i) = self.check.get(&x) {",
			"            *self.counter.entry(x).or_insert(0) += 1;",
			"        } else {",
			"            self.check.insert(x);",
			"            *self.counter.entry(x).or_insert(0) += 1;",
			"        }",
			"        return Some(x);",
			"    }",
			"    pub fn contains(&self, x: T) -> bool",
			"    where",
			"        T: Copy + Clone + Ord + Hash,",
			"    {",
			"        if let Some(_x) = self.check.get(&x) {",
			"            return true;",
			"        } else {",
			"            return false;",
			"        }",
			"    }",
			"    pub fn remove(&mut self, x: T) -> Option<T>",
			"    where",
			"        T: Copy + Clone + Ord + Hash,",
			"    {",
			"        if let Some(_x) = self.check.get(&x) {",
			"            if *self.counter.get(&x).unwrap() == 1 {",
			"                self.counter.remove(&x);",
			"                self.check.remove(&x);",
			"                return Some(x);",
			"            } else {",
			"                let v = self.counter.get_mut(&x);",
			"                match v {",
			"                    Some(v) => *v -= 1,",
			"                    None => (),",
			"                }",
			"                return Some(x);",
			"            }",
			"        } else {",
			"            None",
			"        }",
			"    }",
			"    pub fn remove_all(&mut self, x: T) -> Option<T> {",
			"        if let Some(_x) = self.check.get(&x) {",
			"            self.counter.remove(&x);",
			"            self.check.remove(&x);",
			"            return Some(x);",
			"        } else {",
			"            None",
			"        }",
			"    }",
			"    pub fn clear(&mut self) -> bool {",
			"        if !self.check.is_empty() {",
			"            self.check.clear();",
			"            self.counter.clear();",
			"            return true;",
			"        } else {",
			"            return false;",
			"        }",
			"    }",
			"    pub fn is_empty(&self) -> bool {",
			"        if self.check.is_empty() {",
			"            true",
			"        } else {",
			"            false",
			"        }",
			"    }",
			"    pub fn show(&self)",
			"    where",
			"        T: std::fmt::Display,",
			"    {",
			"        if self.check.is_empty() {",
			"            println!(\"None\");",
			"        } else {",
			"            let iter = self.check.iter().clone();",
			"            for v in iter {",
			"                let num_iteration = self.counter.get(v).unwrap();",
			"                for _n in 0..*num_iteration {",
			"                    print!(\"{} \", v);",
			"                }",
			"            }",
			"            println!();",
			"        }",
			"    }",
			"}"
		],
		"description": "Provide MultiSet data structure like C++"
	},
	"rangeset": {
		"prefix": "rangeset",
		"body": [
			"pub struct RangeSet {",
			"    st: BTreeSet<(usize, usize)>,",
			"    range_length: usize,",
			"}",
			"impl RangeSet {",
			"    pub fn new() -> Self {",
			"        let st: BTreeSet<(usize, usize)> = BTreeSet::new();",
			"        let range_length = 0;",
			"        return RangeSet { st, range_length };",
			"    }",
			"    pub fn len(&self) -> usize {",
			"        return self.st.len();",
			"    }",
			"    pub fn range_len(&self) -> usize {",
			"        return self.range_length;",
			"    }",
			"    pub fn find(&self, kth: &usize) -> Option<(usize, usize)> {",
			"        let mut lower_bound = self.st.range((Unbounded, Excluded((kth + 1, kth + 1))));",
			"        let value = lower_bound.next_back();",
			"        match value {",
			"            Some(ret) => {",
			"                if ret.1 < *kth {",
			"                    return None;",
			"                } else {",
			"                    return value.copied();",
			"                }",
			"            }",
			"            None => return None,",
			"        }",
			"    }",
			"    pub fn contains(&self, kth: &usize) -> bool {",
			"        let value = self.find(kth);",
			"        match value {",
			"            Some(_ret) => return true,",
			"            None => return false,",
			"        }",
			"    }",
			"    pub fn insert(&mut self, mut left: usize, mut right: usize) {",
			"        assert!(left <= right);",
			"        let mut small = self.st.range((Unbounded, Excluded((left + 1, left + 1))));",
			"        while let Some((u, v)) = small.next_back() {",
			"            if left <= (*v) + 1 {",
			"                left = min(*u, left);",
			"            }",
			"        }",
			"        let mut large = self.st.range((Included((left, right + 1)), Unbounded));",
			"        while let Some((u, v)) = large.next() {",
			"            if *u == 0 || right >= (*u) - 1 {",
			"                right = max(right, *v);",
			"            }",
			"        }",
			"        let will_remove = self",
			"            .st",
			"            .range((Included((left, left)), Included((right, right))));",
			"        let mut remover: Vec<(usize, usize)> = Vec::new();",
			"        for rem in will_remove {",
			"            remover.push(*rem);",
			"            self.range_length -= rem.1 - rem.0 + 1;",
			"        }",
			"        for rem in remover {",
			"            self.st.remove(&rem);",
			"            self.range_length += rem.1 - rem.0 + 1;",
			"        }",
			"        self.st.insert((left, right));",
			"    }",
			"    pub fn remove(&mut self, left: usize, right: usize) {",
			"        assert!(left <= right);",
			"        self.range_length -= right - left + 1;",
			"        match self.find(&left) {",
			"            Some((u, v)) => {",
			"                self.st.remove(&(u, v));",
			"                if left != u {",
			"                    self.insert(u, left - 1);",
			"                }",
			"                if right != v {",
			"                    self.insert(right + 1, v);",
			"                }",
			"            }",
			"            None => panic!(\"out of range\"),",
			"        }",
			"    }",
			"}",
			""
		],
		"description": "rangeset"
	},
	"prime factorize": {
		"prefix": "prime factorize",
		"body": [
			"#[allow(non_snake_case)]",
			"fn prime_factorize(mut x: i64) -> Vec<(i64, i64)> {",
			"    let mut factor: Vec<(i64, i64)> = Vec::new();",
			"    let sq = x.sqrt() + 1;",
			"    let mut isSeeked = vec![true; sq as usize + 1];",
			"    for i in 2..=sq {",
			"        if !isSeeked[i as usize] {",
			"            continue;",
			"        }",
			"        let mut exp_num = 0;",
			"        while x % i == 0 {",
			"            exp_num += 1;",
			"            x /= i;",
			"        }",
			"        for n in (i * 2..=sq).step_by(i as usize) {",
			"            isSeeked[n as usize] = false;",
			"        }",
			"        if exp_num != 0 {",
			"            factor.push((i, exp_num));",
			"        }",
			"    }",
			"    if x > 1 {",
			"        factor.push((x, 1));",
			"    }",
			"    return factor;",
			"}"
		],
		"description": "prime factorize"
	},
	"Calculate shortest path by using Dijkstra's Method": {
		"prefix": "dijkstra",
		"body": [
			"#[allow(non_snake_case)]",
			"#[derive(Clone)]",
			"struct Edge {",
			"    to: usize,",
			"    cost: i64,",
			"}",
			"",
			"#[derive(Clone)]",
			"struct Dijkstra {",
			"    graph: Vec<Vec<Edge>>,",
			"    from_record: Vec<usize>,",
			"    nodes: usize,",
			"}",
			"",
			"impl Dijkstra {",
			"    pub fn new(n: usize) -> Self {",
			"        let graph: Vec<Vec<Edge>> = vec![Vec::new(); n];",
			"        let from_record: Vec<usize> = vec![n + 1; n];",
			"        let nodes = n;",
			"        return Dijkstra {",
			"            graph,",
			"            from_record,",
			"            nodes,",
			"        };",
			"    }",
			"    pub fn add_edge(&mut self, from: usize, to: usize, cost: i64) {",
			"        assert!(from != to);",
			"        self.graph[from].push(Edge { to, cost });",
			"    }",
			"    pub fn calc_shortest_distance(&mut self, start: usize) -> Vec<i64> {",
			"        let mut dist = vec![1e18 as i64 + 1; self.nodes];",
			"        //min-heap",
			"        let mut heap: BinaryHeap<(std::cmp::Reverse<i64>, usize)> = BinaryHeap::new();",
			"        heap.push((Reverse(0), start));",
			"        dist[start] = 0;",
			"        while let Some((Reverse(min_dist), v)) = heap.pop() {",
			"            if dist[v] < min_dist {",
			"                continue;",
			"            }",
			"            for e in &self.graph[v] {",
			"                if dist[e.to] > dist[v] + e.cost {",
			"                    dist[e.to] = dist[v] + e.cost;",
			"                    heap.push((Reverse(dist[e.to]), e.to));",
			"                    self.from_record[e.to] = v;",
			"                }",
			"            }",
			"        }",
			"        return dist;",
			"    }",
			"    pub fn get_shortest_path(&mut self, mut goal: usize) -> Vec<usize> {",
			"        let mut path: Vec<usize> = Vec::new();",
			"        while goal != self.nodes {",
			"            path.push(goal);",
			"            goal = self.from_record[goal];",
			"        }",
			"        return path;",
			"    }",
			"}"
		],
		"description": "Calculate shortest path by using Dijkstra's Method"
	}
}