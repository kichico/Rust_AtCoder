{
	// Place your snippets for rust here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"modpow": {
		"prefix": "modpow",
		"body": [
			"#[allow(non_snake_case)]",
			"fn modpow(mut x: i128, mut n: i128, MOD: i128) -> i128 {",
			"    let mut ans = 1;",
			"    while n > 0 {",
			"        if n & 1 == 1 {",
			"            ans = (ans * x) % MOD;",
			"        }",
			"        x = (x * x) % MOD;",
			"        n >>= 1;",
			"    }",
			"    return ans;",
			"}",
			""
		],
		"description": ""
	},
	"to_Binary": {
		"prefix": "to_Binary",
		"body": [
			"#[allow(non_snake_case)]",
			"fn to_Binary(mut x: i128) -> Vec<char> {",
			"    let mut v: Vec<char> = Vec::new();",
			"    if x == 0 {",
			"        v.push('0');",
			"    }",
			"    while x > 0 {",
			"        let c = std::char::from_digit((x % 2) as u32, 10).unwrap();",
			"        v.push(c);",
			"        x /= 2;",
			"    }",
			"    v.reverse();",
			"    return v;",
			"}"
		],
		"description": ""
	},
	"BinarySearch": {
		"prefix": "BinarySearch",
		"body": [
			"let (mut left,mut right):(usize,usize)=(0,n);",
			"while right-left > 1{",
			"  let mid: usize = left + (right - left)/2;",
			"  if a[mid] > x {",
			"      right = mid;",
			"  }",
			"  else {",
			"      left = mid;",
			"  }",
			"}"
		],
		"description": "BinarySearch"
	},
	"grid": {
		"prefix": "grid",
		"body": [
			"#[allow(non_snake_case)]",
			"fn grid<T: Clone + Copy>(h: usize, w: usize, ini: T) -> Vec<Vec<T>> {",
			"    let ret: Vec<Vec<T>> = vec![vec![ini; w]; h];",
			"    return ret;",
			"}"
		],
		"description": "grid"
	},
	"enumeratePrime": {
		"prefix": "enumeratePrime",
		"body": [
			"fn isPrime(x: i64) -> bool {",
			"    for i in 2..x.sqrt() as i64 + 1 {",
			"        if x % i == 0 {",
			"            return false;",
			"        }",
			"    }",
			"    return true;",
			"}",
			"",
			"fn enumeratePrime(x: i64) -> Vec<i64> {",
			"    let mut prime: Vec<i64> = Vec::new();",
			"    let mut notp = vec![false; 1e6 as usize + 1];",
			"    for i in 2..min(x as usize + 1, 1e6 as usize) {",
			"        if notp[i] {",
			"            continue;",
			"        }",
			"        if isPrime(i as i64) {",
			"            prime.push(i as i64);",
			"        }",
			"        let mut coe = 1;",
			"        while coe * i <= x as usize {",
			"            notp[coe * i] = true;",
			"            coe += 1;",
			"        }",
			"    }",
			"    return prime;",
			"}",
		],
		"description": ""
	},
	"enumerateDivisor": {
		"prefix": "enumerateDivisor",
		"body": [
			"fn enumerateDivisor(x: i64) -> HashSet<i64> {",
			"    let mut Divisor: HashSet<i64> = HashSet::new();",
			"    let limit = x.sqrt() + 2;",
			"    for num in 1..limit {",
			"        if x % num == 0 {",
			"            Divisor.insert(num);",
			"            Divisor.insert(x / num);",
			"        }",
			"    }",
			"    return Divisor;",
			"}",
			""
		],
		"description": "enumerateDivisor"
	},
	"Disjoint Set and Union data structure": {
		"prefix": "UnionFind",
		"body": [
			"#[derive(Debug, Clone)]",
			"pub struct UnionFind {",
			"    parent: Vec<i64>,",
			"}",
			"",
			"impl UnionFind {",
			"    pub fn new(n: usize) -> Self {",
			"        let parent = vec![-1i64; n];",
			"        return UnionFind { parent };",
			"    }",
			"    pub fn find_root(&mut self, x: usize) -> usize {",
			"        if self.parent[x] < 0 {",
			"            return x;",
			"        }",
			"        self.parent[x] = self.find_root(self.parent[x] as usize) as i64;",
			"        return self.parent[x] as usize;",
			"    }",
			"    pub fn unite(&mut self, x: usize, y: usize) {",
			"        let mut xpar = self.find_root(x);",
			"        let mut ypar = self.find_root(y);",
			"        if xpar == ypar {",
			"            return;",
			"        }",
			"        if self.parent[xpar] > self.parent[y] {",
			"            swap(&mut xpar, &mut ypar);",
			"        }",
			"        let x = xpar;",
			"        let y = ypar;",
			"        self.parent[x] += self.parent[y];",
			"        self.parent[y] = x as i64;",
			"    }",
			"    pub fn size(&mut self, x: usize) -> i64 {",
			"        let x = self.find_root(x);",
			"        return -self.parent[x];",
			"    }",
			"    pub fn equiv(&mut self, x: usize, y: usize) -> bool {",
			"        let x = self.find_root(x);",
			"        let y = self.find_root(y);",
			"        return x == y;",
			"    }",
			"}"
		],
		"description": "Disjoint Set and Union data structure"
	},
	"provide MultiSet Data Stracture": {
		"prefix": "MultiSet",
		"body": [
			"#[derive(Debug, Clone)]",
			"pub struct MultiSet<T>",
			"where",
			"    T: Copy + Clone + Hash + Eq + Ord,",
			"{",
			"    check: BTreeSet<T>,",
			"    counter: HashMap<T, i64>,",
			"    cnt: i64,",
			"}",
			"impl<T> MultiSet<T>",
			"where",
			"    T: Copy + Clone + Hash + Eq + Ord,",
			"{",
			"    pub fn new() -> Self {",
			"        let check: BTreeSet<T> = BTreeSet::new();",
			"        let counter: HashMap<T, i64> = HashMap::new();",
			"        let cnt = 0;",
			"        return MultiSet {",
			"            check,",
			"            counter,",
			"            cnt,",
			"        };",
			"    }",
			"    pub fn max(&self) -> Option<&T> {",
			"        if let Some(max_value) = self.check.iter().next_back() {",
			"            return Some(max_value);",
			"        } else {",
			"            return None;",
			"        }",
			"    }",
			"    pub fn min(&self) -> Option<&T> {",
			"        if let Some(min_value) = self.check.iter().next() {",
			"            return Some(min_value);",
			"        } else {",
			"            return None;",
			"        }",
			"    }",
			"    pub fn insert(&mut self, x: T) -> Option<T>",
			"    where",
			"        T: Copy + Clone + Ord + Hash,",
			"    {",
			"        if let Some(_i) = self.check.get(&x) {",
			"            *self.counter.entry(x).or_insert(0) += 1;",
			"        } else {",
			"            self.check.insert(x);",
			"            *self.counter.entry(x).or_insert(0) += 1;",
			"        }",
			"        return Some(x);",
			"    }",
			"    pub fn contains(&self, x: T) -> bool",
			"    where",
			"        T: Copy + Clone + Ord + Hash,",
			"    {",
			"        if let Some(_x) = self.check.get(&x) {",
			"            return true;",
			"        } else {",
			"            return false;",
			"        }",
			"    }",
			"    pub fn remove(&mut self, x: T) -> Option<T>",
			"    where",
			"        T: Copy + Clone + Ord + Hash,",
			"    {",
			"        if let Some(_x) = self.check.get(&x) {",
			"            if *self.counter.get(&x).unwrap() == 1 {",
			"                self.counter.remove(&x);",
			"                self.check.remove(&x);",
			"                return Some(x);",
			"            } else {",
			"                let v = self.counter.get_mut(&x);",
			"                match v {",
			"                    Some(v) => *v -= 1,",
			"                    None => (),",
			"                }",
			"                return Some(x);",
			"            }",
			"        } else {",
			"            None",
			"        }",
			"    }",
			"    pub fn remove_all(&mut self, x: T) -> Option<T>",
			"    where",
			"        T: Copy + Clone + Ord + Hash,",
			"    {",
			"        if let Some(_x) = self.check.get(&x) {",
			"            self.counter.remove(&x);",
			"            self.check.remove(&x);",
			"            return Some(x);",
			"        } else {",
			"            None",
			"        }",
			"    }",
			"    pub fn clear(&mut self) -> bool",
			"    where",
			"        T: Copy + Clone + Ord + Hash,",
			"    {",
			"        if !self.check.is_empty() {",
			"            self.check.clear();",
			"            self.counter.clear();",
			"            return true;",
			"        } else {",
			"            return false;",
			"        }",
			"    }",
			"    pub fn is_empty(&self) -> bool {",
			"        if self.check.is_empty() {",
			"            true",
			"        } else {",
			"            false",
			"        }",
			"    }",
			"}"
		],
		"description": "provide MultiSet Data Stracture"
	}
}